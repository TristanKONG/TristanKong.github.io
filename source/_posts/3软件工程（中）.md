---

title: 软件工程（中） 

date: 2024-10-12 11:00:00 


categories: Notes 

---



### 四、面向对象与ＵＭＬ

#### 面向对象

- 对象和类

	- 对象

		- 面向对象技术的核心

		- 封装体

			- 数据以及在其上操作

		- 集合

			- 是具有唯一对象名和固定对外接口的一组属性和操作

	- 类

		- 一组相似的对象的共性抽象

		- 有效模板

			- 创建对象

		- 工具

			- 实现抽象数据类型

- 面向对象的基本特征

	- 抽象abstraction

		- 在某个侧面来表示某个物体或概念

		- 忽略主题中于当前目标无关的因素

	- 封装encapsulation

		- 把操作和数据包围起来

		- 对数据的访问只通过已定义的接口来完成

	- 继承inheritance

		- 类的层次模型

		- 一种表述共性的方法

	- 多态polymorphism

		- 不同类的对象对同一消息执行不同的处理

- 优点

	- 提高软件系统的

		- 可复用性

		- 可扩展性

		- 可维护性

#### UML

- 概念

	- 统一建模语言Unified modeling language

	- 基于面向对象的可视化建模语言

	- 表示

		- 用图表示它的语法

		- 用元模型表达它的语义

		- 采用模型来描述系统的结构（或静态特征）及行为（或动态特征）

- 组成

	- 两类模型元素

		- 表示概念

		- 表示连接关系

			- 官时饭依剧组

			- 关联

				-  

			- 实现

				-  

			- 泛化（继承）

				-  

			- 依赖

				-  

			- 聚集（聚合）

				-  

			- 组合

				- “部分”不能独立于“整体”而存在

				-  

	- 四个抽象层次

		- 元元模型

			- 描述元模型

		- 元模型

			- 描述模型

		- 模型

			- 描述信息领域

		- 用户模型

			- 模型的实例

	- 图和视图

		- 图diagram

			- 静态图

				- 用例图

					- 用例之间的关系

						- 扩展关系

						- 包含关系

				- 类图

					- 可见性

						- public +

						- private -

						- protected #

					- 操作的语法

						- 可见性 操作名(参数表) : 返回类型{约束特性}

				- 对象图

				- 构件图

				- 部署图

			- 动态图

				- 状态图

					- 描述

						- 一个特定对象的所有可能状态

						- 引起其状态转移的事件

				- 时序图

				- 协作图

				- 活动图

		- 视图view

			- 用例视图

			- 逻辑视图

			- 进程视图

			- 构件视图

			- 部署视图

- 特点

	- 同一标准

	- 面向对象

	- 表达能力强大、可视化

- 应用

	- UML模型可作为测试阶段的依据

- 建模机制

	- 静态建模

		- 由5图表示

			- 用泪兑狗布

			- 用例图

			- 类图

			- 对象图

			- 构件图

			- 部署图

	- 动态建模

		- 由4图表示

			- 壮士卸货

			- 状态图

			- 时序图

			- 协作图

			- 活动图

		- 消息

			- 简单消息

			- 同步消息

			- 异步消息

#### 物理架构建模

#### UML工具

- Rational Rose

	- 对软件系统进行面向对象分析和设计的可视化工具

	- Rose模型

		- 4个视图

			- 用例视图

			- 逻辑视图

			- 构件视图

			- 部署视图

- StarUML

	- 运行在Windows上的UML/MDA平台

### 五、需求工程与需求分析

#### 软件需求工程

- 定义

	- 一个软件系统必须遵循的条件或具备的能力

		- 系统的外部行为

			- 用户解决问题或达到目标所需具有的条件或能力

		- 系统的内部特性

			- 系统为了满足合同、规范或其他规定文档所需具有的条件或能力

	- 3个层次

		- 业务需求

			- 项目愿景和范围

		- 用户需求

			- 用例模型文档

			- 质量属性

		- 功能需求

			- SRS

- 6个特性

	- 功能性

		- 普通功能

		- 全局性功能

	- 可用性

	- 可靠性

	- 性能

	- 可支持性

	- 设计约束

#### 需求分析

- 目的

	- 为待开发的软件系统进行需求定义与分析

	- 并建立一个需求模型

- 4个步骤

	- 需求获取

		- 常用方法

			- 常规方法

				- 建立联合分析小组

					- 用户

					- 系统分析员

					- 领域专家

				- 用户访谈

				- 问题分析与确认

			- 快速原型法

				- 获取两个层面上的需求

					- 联机屏幕

					- 模拟系统的外部特征

	- 需求建模

		- 需求模型

			- 结构化需求模型

			- 面向对象需求模型

				- 3个组成部分

					- 用例模型

						- 用例图

						- 用例规约

					- 补充规约

					- 术语表

		- 面向对象需求建模

			- 4步

				- 画用例图

					- 确定参与者

					- 确定用例

					- 绘制和检查用例图

				- 写用例规约

					- 用例规约内容

						- 简要说明

						- 事件流

							- 基本流

							- 备选流

						- 特殊需求

						- 前置条件和后置条件

					- 用例模式的检查

						- 功能需求的完备性

						- 模型是否易于理解

						- 是否存在不一致性

						- 避免二义性语义

				- 描述补充规约

				- 编写术语表

	- 需求描述

		- 编写SRS

			- 主体

				- 描述软件系统的分析模型

					- 信息描述

						- 软件所含信息的详细描述

					- 功能描述

						- 软件功能需求的说明

					- 行为描述

						- 系统状态变化以及事件和动作的叙述

	- 需求验证

		- 验证SRS

### 需求管理

- 需求变更

	- 流程

		- 变更申请

		- 变更审批

		- 变更修改

		- 变更关闭

### 六、面向对象分析

#### 概述

- 面向对象软件分析(object-oriented analysis,OOA)

	- 主要任务

		- 理解用户需求

			- 理解和分析用户需求

			- 明确所开发的软件系统的职责

			- 形成文件并规范地加以表述

		- 分析，提取类和对象，并结合分析进行建模

	- OOA模型

		- 以用例模型为主体的需求模型（核心）

			- 类/对象模型

			- 对象-关系模型

			- 对象-行为模型

	- 优点

		- 对需求的变化具有较强的适应性

		- 支持软件复用

	- 分析模型的一般特点

		- 全面覆盖软件的功能需求

		- 分析模型与软件的实现 无关

		- 分析模型的表述方法与所采用的分析技术有关

- 面向对象分析模型

	- 五层次模型

		- 类/对象层

		- 属性层

		- 服务层

			- 动态属性

				- 对象

				- 类

			- 消息通信

				- 对象之间

		- 结构层

			- 对象和类的层次结构关系

				- 包含

				- 继承

				- 关联

		- 主题层

			- 每个主题是一个子系统

				- 包含有关对象

	- OOA方法

		- 共同特征

			- 类和类层次的表示

			- 建立对象-关系模型

			- 建立对象-行为模型

		- 建模步骤

			- 需求理解

			- 定义类和对象

			- 表示对象的属性和操作

			- 表示类的结构和层次

			- 建立对象-关系模型

			- 建立对象-行为模型

	- 面向对象软件开发的全（迭代）过程

		- 1. OOA（分析）

		- 2. OOD（设计）

		- 3. OOP（编程）

		- 4. OOT（测试）

#### 面向对象分析建模

- 识别与确定分析类

	- 分析类的类型

		- 边界类

			- 提供接口

				- 对参与者

				- 对外部系统交互协议

			- 种类

				- 用户界面类

				- 系统接口类

				- 设备接口类

		- 控制类

			- 封装

				- 一个或几个用例所特有的流程控制行为

		- 实体类

			- 存储和管理系统中的信息

	- 查找分析类

		- 为每对 参与者/用例 确定一个边界类

		- 为每个用例设置一个控制类

		- 确定相关的各个实体（包括属性与方法）

- 建立对象-行为模型（动态模型）

	- 时序图

	- 协作图

	- 为分析类分配职责

	- 状态图

- 建立对象-关系模型（静态模型）

	- 分析类的属性

	- 分析类的关联

	- 分析类图

	- 分析类的合并

### 七、面向对象设计

#### 软件设计

- 概念

	- 两种主流的设计方法

		- 结构化软件设计

			- 以结构化程序设计为基础

		- 面向对象软件设计

			- 由面向对象方法导出

	- 模块与构件

		- 模块(module)

			- 一个拥有明确定义的输入、输出和特性的程序实体

		- 软件构件(software component)

			- 可重复使用的软件组件

			- 现有可复用的构件

				- 大多是在对象的基础上创建的

	- 抽象(abstraction)与细化(refinement)

	- 信息隐藏(information hiding)

		- 把系统分解为模块时应遵守的指导思想

		- 发展

			- 数据封装(data encapsulation)

			- 抽象数据类型(abstract datatype)

			- 类和对象

	- 软件复用

- 任务

	- 将分析现阶段建立的分析模型转变为软件设计模型，确保最终能平滑地过渡到程序代码

	- 内容

		- 数据设计

			- 将信息模型转变为数据结构

		- 体系结构设计

			- 定义软件主要组成部件之间的关系

		- 接口设计

			- 软件内部

			- 软件和接口系统之间

			- 软件与人之间

			- 数据流和控制流

		- 过程设计

			- 将软件体系结构的组成部件转变为对软件组件的过程性描述

- 模块化设计(modular design)

	- 目的

		- 按照规定的原则把大型软件划分为一个个较小的、相对独立但相互关联的模块

	- 指导思想

		- 分解(decomposition)

		- 模块独立性(module independence)

			- 度量

				- 内聚(cohesion)

					- 也称为块内联系或模块强度

					- 指模块内部各个成分之间的联系

					- 是从功能的角度对模块内部聚合能力的量度

					- 强度分类

						- 低内聚

							- 偶然性内聚

							- 逻辑性内聚

							- 时间性内聚

						- 中内聚

							- 过程性内聚

							- 通信性内聚

						- 高内聚

							- 顺序性内聚

							- 功能性内聚

				- 耦合(coupling)

					- 又称块间联系

					- 指一个模块与其他模块间的联系

					- 是对软件内部块间联系的度量

					- 强度分类

						- 弱耦合

							- 非直接耦合

							- 数据耦合

							- 特征耦合

						- 中耦合

							- 控制耦合

						- 较强耦合

							- 外部耦合

							- 公共耦合

						- 强耦合

							- 内容耦合

#### 面向对象设计建模

- OO设计模型

	- 责任设计

	- 消息设计

	- 类和对象设计

	- 系统架构设计

- OO设计的任务

	- 系统架构设计

		- 系统架构师

		- 软件系统架构

			- 指系统主要组成元素的组织或结构，以及其他全局性决策

			- 组成元素之间通过接口进行交互

		- 内容

			- 系统高层结构设计

			- 确定设计元素

			- 确定任务管理策略

			- 实现分布式机制

			- 设计数据存储方案

			- 人机界面设计

	- 系统元素设计

		- 软件设计师

		- 系统元素

			- 类

			- 子系统

			- 接口

			- 包

			- 等等...

		- 系统元素设计

			- 对每一个设计元素进行详细的设计

		- 内容

			- 类/对象设计

			- 子系统设计

			- 包设计

- 模式的应用

	- 模式的定义

		- 解决某一类问题的方法论，对通用问题的通用解决方案

	- 软件模式的分类

		- 架构模式

			- 软件系统的基本结构组织方案

		- 设计模式

			- 面向对象的具体设计问题的解决方案

		- 习惯用法

			- 针对具体程序设计语言的使用模式

#### 系统架构设计

- 系统高层结构设计

	- 4个层次

		- 应用子系统层

		- 业务专用层

		- 中间件层

		- 系统软件层

- 确定设计元素

	- 映射分析类到设计元素

	- 确定子系统

		- 指导性参考原则

			- 对象协作原则

			- 可选性原则

			- 用户界面原则

			- 参与者原则

			- 耦合和内聚原则

			- 分布原则

	- 定义子系统接口

		- 步骤

			- 1. 为子系统确定一个备选接口集

			- 2. 寻找接口之间的相似点

			- 3. 定义接口依赖关系

			- 4. 将接口映射到子系统

			- 5. 定义接口所指定的行为

		- 表述

			- 在相应类的名称前加上前缀"I-"

			- 或将类加上"<<interface>>"

- 任务管理策略

	- 并行需求

		- 3种解决方案

			- 多处理器

			- 操作系统

			- 应用程序

		- 两种实现并行需求的技术

			- 引进任务管理部件

			- 基于进程和线程的控制

				- 进程和线程建模

					- 标识

						- 进程

							- <<process>>

						- 线程

							- <<thread>>

					- 进程

						- 进程间的通信是依赖关系

						- 对进程建模可采用

							- 类图

							- 构件图

						- 进程间联系

							- 独立的进程

								- 依赖关系

							- 有线程

								- 组合关系

				- 确定进程的生存周期

					- 单进程架构

						- 进程在应用程序开始和结束时创建和销毁

					- 多进程架构

						- 新进程（或线程）在应用程序开始时

							- 从初始进程中产生或派生

							- 必须显式销毁

- 分布式实现机制

	- 确定网络拓扑配置

		- 网络的物理布局（包括位置）

		- 网络的结点及结点的配置与性能

		- 网络中的各网段带宽

		- 网络中的冗余路径（容错能力）

		- 结点的分类

	- 将设计元素分配到网络结点

	- 设计分布处理机制

		- 需要底层类库的支持

			- Microsoft.NET平台

			- Java平台

				- 远程方法调用(remote method invoaction, RMI)

					- 1. 引入可直接利用的类库

						- Naming

						- Serializable

						- Remote

					- 2. 建立一些带有"<<role>>"标识的类，代表实际设计元素

						- <<role>> SampleDistributedClass

							- 分布类

						- <<role>> SampleDistributedClassClient

							- 分布类的客户

						- <<role>> SamplePassedData

							- 被作为参数传递的对象所对应的设计元素

						- <<interface>> ISampleDistributedClass

							- 被分布到异地的分布类在本地的“代言人”

					- 3. 描述分布机制的静态结构

- 数据存储设计

- 人机交互设计

	- 1. 根据用户特点设计不同界面

	- 2. 增加用户界面专用的类与对象

	- 3. 利用快速原型演示，来改进界面设计

#### 系统元素设计

- 子系统设计

	- 1. 将子系统行为分配给子系统元素

	- 2.描述子系统元素

	- 3. 说明子系统的依赖关系

- 分包设计

	- 分包原则

		- 将边界类打包

			- 接口可能被替换

				- 将接口与设计模型的其他部分隔离开

			- 接口不易被替换

				- 对系统服务分包，将边界类和功能相关的实体类及控制类放置在一起

		- 将功能相关的类打包

- 类/对象设计

	- 创建初始设计类

		- 设计边界类

		- 设计实体类

		- 设计控制类

			- 复杂性

			- 变更的可能性

			- 分布和性能

			- 事物管理

	- 定义操作

		- 命名和说明操作

		- 定义操作可见性

		- 定义操作的作用域

	- 定义方法

	- 定义状态

		- 确定一个类是否具有重要的动态行为

			- 检查类的属性

			- 检查类的关联

	- 定义属性

		- 属性名

		- 属性类型

		- 属性的默认值或初始值

		- 属性的可见性

			- 公有

				- public

			- 保护

				- protected

			- 私有

				- private

	- 定义依赖关系

		- 属于不同类的两个对象a、b的四种连接可见度

			- 全局(global)

			- 参数(parameter)

			- 局部(local)

			- 域(field)

	- 定义关联关系

		- 进一步明确或改进细节内容

			- 聚集还是组合

			- 属性还是组合

			- 关联的方向

			- 关联类

			- 确定重数

	- 定义泛化关系

	- 处理非功能性需求

### 八、编码与测试

#### 编码

- 概述

	- 目的

		- 把详细设计的结果“翻译”成选定的程序设计语言书写的源程序

	- 编码风格

		- 使用标准的控制结构

		- 实现源程序的文档化

			- 有意义的变量名称

			- 适当的注释

			- 标准的书写格式

		- 满足用户友好的输入输出风格

- 编码语言

	- 基础语言

		- FORTRAN

		- COBOL

		- BASIC

	- 结构化语言

		- C

		- Pascal

		- Ada

	- 面向对象语言

		- C++

		- Java

		- C#

#### 测试

- 多模块程序的测试策略

	- 层次性

		- 单元测试(unit testing)

			- 编译

			- 静态分析器检查

			- 代码评审

				- 办公桌检查

				- 小组会

					- 走查

					- 代码会审

			- 动态测试

				- 黑盒

				- 白盒

		- 集成测试(integration testing)

			- 策略

				- 自顶向下

				- 由底向上

				- 混合方式

		- 高级测试

			- 确认测试(validation testing)

				- 有效性测试（黑盒测试）和配置复审

				- 验收测试

				- α与β测试

			- 系统测试(system testing)

	- 终止测试的标准

		- 规定测试策略和应达目标

		- 规定至少要查出的错误数量

- 面向对象系统的测试

	- OO软件系统需要比传统软件系统更多的测试

	- OO软件的测试策略

		- 单元测试

			- 单元

				- 封装的类和对象

		- 集成测试

			- 只能进行基于黑盒方法的集成测试

			- 测试策略

				- 基于线程的测试

				- 基于使用的测试

		- 高级测试

			- 确认测试

			- 系统测试

